{"ast":null,"code":"const Transport = require(\"../transport\");\n\nconst parser = require(\"engine.io-parser\");\n\nconst parseqs = require(\"parseqs\");\n\nconst yeast = require(\"yeast\");\n\nconst {\n  pick\n} = require(\"../util\");\n\nconst {\n  WebSocket,\n  usingBrowserWebSocket,\n  defaultBinaryType,\n  nextTick\n} = require(\"./websocket-constructor\");\n\nconst debug = require(\"debug\")(\"engine.io-client:websocket\"); // detect ReactNative environment\n\n\nconst isReactNative = typeof navigator !== \"undefined\" && typeof navigator.product === \"string\" && navigator.product.toLowerCase() === \"reactnative\";\n\nclass WS extends Transport {\n  /**\n   * WebSocket transport constructor.\n   *\n   * @api {Object} connection options\n   * @api public\n   */\n  constructor(opts) {\n    super(opts);\n    this.supportsBinary = !opts.forceBase64;\n  }\n  /**\n   * Transport name.\n   *\n   * @api public\n   */\n\n\n  get name() {\n    return \"websocket\";\n  }\n  /**\n   * Opens socket.\n   *\n   * @api private\n   */\n\n\n  doOpen() {\n    if (!this.check()) {\n      // let probe timeout\n      return;\n    }\n\n    const uri = this.uri();\n    const protocols = this.opts.protocols; // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n\n    const opts = isReactNative ? {} : pick(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n\n    if (this.opts.extraHeaders) {\n      opts.headers = this.opts.extraHeaders;\n    }\n\n    try {\n      this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);\n    } catch (err) {\n      return this.emit(\"error\", err);\n    }\n\n    this.ws.binaryType = this.socket.binaryType || defaultBinaryType;\n    this.addEventListeners();\n  }\n  /**\n   * Adds event listeners to the socket\n   *\n   * @api private\n   */\n\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      if (this.opts.autoUnref) {\n        this.ws._socket.unref();\n      }\n\n      this.onOpen();\n    };\n\n    this.ws.onclose = this.onClose.bind(this);\n\n    this.ws.onmessage = ev => this.onData(ev.data);\n\n    this.ws.onerror = e => this.onError(\"websocket error\", e);\n  }\n  /**\n   * Writes data to socket.\n   *\n   * @param {Array} array of packets.\n   * @api private\n   */\n\n\n  write(packets) {\n    this.writable = false; // encodePacket efficient as it uses WS framing\n    // no need for encodePayload\n\n    for (let i = 0; i < packets.length; i++) {\n      const packet = packets[i];\n      const lastPacket = i === packets.length - 1;\n      parser.encodePacket(packet, this.supportsBinary, data => {\n        // always create a new object (GH-437)\n        const opts = {};\n\n        if (!usingBrowserWebSocket) {\n          if (packet.options) {\n            opts.compress = packet.options.compress;\n          }\n\n          if (this.opts.perMessageDeflate) {\n            const len = \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n\n            if (len < this.opts.perMessageDeflate.threshold) {\n              opts.compress = false;\n            }\n          }\n        } // Sometimes the websocket has already been closed but the browser didn't\n        // have a chance of informing us about it yet, in that case send will\n        // throw an error\n\n\n        try {\n          if (usingBrowserWebSocket) {\n            // TypeError is thrown when passing the second argument on Safari\n            this.ws.send(data);\n          } else {\n            this.ws.send(data, opts);\n          }\n        } catch (e) {\n          debug(\"websocket closed before onclose event\");\n        }\n\n        if (lastPacket) {\n          // fake drain\n          // defer to next tick to allow Socket to clear writeBuffer\n          nextTick(() => {\n            this.writable = true;\n            this.emit(\"drain\");\n          }, this.setTimeoutFn);\n        }\n      });\n    }\n  }\n  /**\n   * Called upon close\n   *\n   * @api private\n   */\n\n\n  onClose() {\n    Transport.prototype.onClose.call(this);\n  }\n  /**\n   * Closes socket.\n   *\n   * @api private\n   */\n\n\n  doClose() {\n    if (typeof this.ws !== \"undefined\") {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n  /**\n   * Generates uri for connection.\n   *\n   * @api private\n   */\n\n\n  uri() {\n    let query = this.query || {};\n    const schema = this.opts.secure ? \"wss\" : \"ws\";\n    let port = \"\"; // avoid port if default for schema\n\n    if (this.opts.port && (\"wss\" === schema && Number(this.opts.port) !== 443 || \"ws\" === schema && Number(this.opts.port) !== 80)) {\n      port = \":\" + this.opts.port;\n    } // append timestamp to URI\n\n\n    if (this.opts.timestampRequests) {\n      query[this.opts.timestampParam] = yeast();\n    } // communicate binary support capabilities\n\n\n    if (!this.supportsBinary) {\n      query.b64 = 1;\n    }\n\n    query = parseqs.encode(query); // prepend ? to query\n\n    if (query.length) {\n      query = \"?\" + query;\n    }\n\n    const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n    return schema + \"://\" + (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + port + this.opts.path + query;\n  }\n  /**\n   * Feature detection for WebSocket.\n   *\n   * @return {Boolean} whether this transport is available.\n   * @api public\n   */\n\n\n  check() {\n    return !!WebSocket && !(\"__initialize\" in WebSocket && this.name === WS.prototype.name);\n  }\n\n}\n\nmodule.exports = WS;","map":null,"metadata":{},"sourceType":"script"}