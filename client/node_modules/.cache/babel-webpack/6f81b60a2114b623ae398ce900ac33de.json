{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Socket = void 0;\n\nconst socket_io_parser_1 = require(\"socket.io-parser\");\n\nconst on_1 = require(\"./on\");\n\nconst typed_events_1 = require(\"./typed-events\");\n\nconst debug = require(\"debug\")(\"socket.io-client:socket\");\n/**\n * Internal events.\n * These events can't be emitted by the user.\n */\n\n\nconst RESERVED_EVENTS = Object.freeze({\n  connect: 1,\n  connect_error: 1,\n  disconnect: 1,\n  disconnecting: 1,\n  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n  newListener: 1,\n  removeListener: 1\n});\n\nclass Socket extends typed_events_1.StrictEventEmitter {\n  /**\n   * `Socket` constructor.\n   *\n   * @public\n   */\n  constructor(io, nsp, opts) {\n    super();\n    this.connected = false;\n    this.disconnected = true;\n    this.receiveBuffer = [];\n    this.sendBuffer = [];\n    this.ids = 0;\n    this.acks = {};\n    this.flags = {};\n    this.io = io;\n    this.nsp = nsp;\n\n    if (opts && opts.auth) {\n      this.auth = opts.auth;\n    }\n\n    if (this.io._autoConnect) this.open();\n  }\n  /**\n   * Subscribe to open, close and packet events\n   *\n   * @private\n   */\n\n\n  subEvents() {\n    if (this.subs) return;\n    const io = this.io;\n    this.subs = [(0, on_1.on)(io, \"open\", this.onopen.bind(this)), (0, on_1.on)(io, \"packet\", this.onpacket.bind(this)), (0, on_1.on)(io, \"error\", this.onerror.bind(this)), (0, on_1.on)(io, \"close\", this.onclose.bind(this))];\n  }\n  /**\n   * Whether the Socket will try to reconnect when its Manager connects or reconnects\n   */\n\n\n  get active() {\n    return !!this.subs;\n  }\n  /**\n   * \"Opens\" the socket.\n   *\n   * @public\n   */\n\n\n  connect() {\n    if (this.connected) return this;\n    this.subEvents();\n    if (!this.io[\"_reconnecting\"]) this.io.open(); // ensure open\n\n    if (\"open\" === this.io._readyState) this.onopen();\n    return this;\n  }\n  /**\n   * Alias for connect()\n   */\n\n\n  open() {\n    return this.connect();\n  }\n  /**\n   * Sends a `message` event.\n   *\n   * @return self\n   * @public\n   */\n\n\n  send(...args) {\n    args.unshift(\"message\");\n    this.emit.apply(this, args);\n    return this;\n  }\n  /**\n   * Override `emit`.\n   * If the event is in `events`, it's emitted normally.\n   *\n   * @return self\n   * @public\n   */\n\n\n  emit(ev, ...args) {\n    if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n      throw new Error('\"' + ev + '\" is a reserved event name');\n    }\n\n    args.unshift(ev);\n    const packet = {\n      type: socket_io_parser_1.PacketType.EVENT,\n      data: args\n    };\n    packet.options = {};\n    packet.options.compress = this.flags.compress !== false; // event ack callback\n\n    if (\"function\" === typeof args[args.length - 1]) {\n      debug(\"emitting packet with ack id %d\", this.ids);\n      this.acks[this.ids] = args.pop();\n      packet.id = this.ids++;\n    }\n\n    const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;\n    const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n\n    if (discardPacket) {\n      debug(\"discard packet as the transport is not currently writable\");\n    } else if (this.connected) {\n      this.packet(packet);\n    } else {\n      this.sendBuffer.push(packet);\n    }\n\n    this.flags = {};\n    return this;\n  }\n  /**\n   * Sends a packet.\n   *\n   * @param packet\n   * @private\n   */\n\n\n  packet(packet) {\n    packet.nsp = this.nsp;\n\n    this.io._packet(packet);\n  }\n  /**\n   * Called upon engine `open`.\n   *\n   * @private\n   */\n\n\n  onopen() {\n    debug(\"transport is open - connecting\");\n\n    if (typeof this.auth == \"function\") {\n      this.auth(data => {\n        this.packet({\n          type: socket_io_parser_1.PacketType.CONNECT,\n          data\n        });\n      });\n    } else {\n      this.packet({\n        type: socket_io_parser_1.PacketType.CONNECT,\n        data: this.auth\n      });\n    }\n  }\n  /**\n   * Called upon engine or manager `error`.\n   *\n   * @param err\n   * @private\n   */\n\n\n  onerror(err) {\n    if (!this.connected) {\n      this.emitReserved(\"connect_error\", err);\n    }\n  }\n  /**\n   * Called upon engine `close`.\n   *\n   * @param reason\n   * @private\n   */\n\n\n  onclose(reason) {\n    debug(\"close (%s)\", reason);\n    this.connected = false;\n    this.disconnected = true;\n    delete this.id;\n    this.emitReserved(\"disconnect\", reason);\n  }\n  /**\n   * Called with socket packet.\n   *\n   * @param packet\n   * @private\n   */\n\n\n  onpacket(packet) {\n    const sameNamespace = packet.nsp === this.nsp;\n    if (!sameNamespace) return;\n\n    switch (packet.type) {\n      case socket_io_parser_1.PacketType.CONNECT:\n        if (packet.data && packet.data.sid) {\n          const id = packet.data.sid;\n          this.onconnect(id);\n        } else {\n          this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n        }\n\n        break;\n\n      case socket_io_parser_1.PacketType.EVENT:\n        this.onevent(packet);\n        break;\n\n      case socket_io_parser_1.PacketType.BINARY_EVENT:\n        this.onevent(packet);\n        break;\n\n      case socket_io_parser_1.PacketType.ACK:\n        this.onack(packet);\n        break;\n\n      case socket_io_parser_1.PacketType.BINARY_ACK:\n        this.onack(packet);\n        break;\n\n      case socket_io_parser_1.PacketType.DISCONNECT:\n        this.ondisconnect();\n        break;\n\n      case socket_io_parser_1.PacketType.CONNECT_ERROR:\n        const err = new Error(packet.data.message); // @ts-ignore\n\n        err.data = packet.data.data;\n        this.emitReserved(\"connect_error\", err);\n        break;\n    }\n  }\n  /**\n   * Called upon a server event.\n   *\n   * @param packet\n   * @private\n   */\n\n\n  onevent(packet) {\n    const args = packet.data || [];\n    debug(\"emitting event %j\", args);\n\n    if (null != packet.id) {\n      debug(\"attaching ack callback to event\");\n      args.push(this.ack(packet.id));\n    }\n\n    if (this.connected) {\n      this.emitEvent(args);\n    } else {\n      this.receiveBuffer.push(Object.freeze(args));\n    }\n  }\n\n  emitEvent(args) {\n    if (this._anyListeners && this._anyListeners.length) {\n      const listeners = this._anyListeners.slice();\n\n      for (const listener of listeners) {\n        listener.apply(this, args);\n      }\n    }\n\n    super.emit.apply(this, args);\n  }\n  /**\n   * Produces an ack callback to emit with an event.\n   *\n   * @private\n   */\n\n\n  ack(id) {\n    const self = this;\n    let sent = false;\n    return function (...args) {\n      // prevent double callbacks\n      if (sent) return;\n      sent = true;\n      debug(\"sending ack %j\", args);\n      self.packet({\n        type: socket_io_parser_1.PacketType.ACK,\n        id: id,\n        data: args\n      });\n    };\n  }\n  /**\n   * Called upon a server acknowlegement.\n   *\n   * @param packet\n   * @private\n   */\n\n\n  onack(packet) {\n    const ack = this.acks[packet.id];\n\n    if (\"function\" === typeof ack) {\n      debug(\"calling ack %s with %j\", packet.id, packet.data);\n      ack.apply(this, packet.data);\n      delete this.acks[packet.id];\n    } else {\n      debug(\"bad ack %s\", packet.id);\n    }\n  }\n  /**\n   * Called upon server connect.\n   *\n   * @private\n   */\n\n\n  onconnect(id) {\n    debug(\"socket connected with id %s\", id);\n    this.id = id;\n    this.connected = true;\n    this.disconnected = false;\n    this.emitBuffered();\n    this.emitReserved(\"connect\");\n  }\n  /**\n   * Emit buffered events (received and emitted).\n   *\n   * @private\n   */\n\n\n  emitBuffered() {\n    this.receiveBuffer.forEach(args => this.emitEvent(args));\n    this.receiveBuffer = [];\n    this.sendBuffer.forEach(packet => this.packet(packet));\n    this.sendBuffer = [];\n  }\n  /**\n   * Called upon server disconnect.\n   *\n   * @private\n   */\n\n\n  ondisconnect() {\n    debug(\"server disconnect (%s)\", this.nsp);\n    this.destroy();\n    this.onclose(\"io server disconnect\");\n  }\n  /**\n   * Called upon forced client/server side disconnections,\n   * this method ensures the manager stops tracking us and\n   * that reconnections don't get triggered for this.\n   *\n   * @private\n   */\n\n\n  destroy() {\n    if (this.subs) {\n      // clean subscriptions to avoid reconnections\n      this.subs.forEach(subDestroy => subDestroy());\n      this.subs = undefined;\n    }\n\n    this.io[\"_destroy\"](this);\n  }\n  /**\n   * Disconnects the socket manually.\n   *\n   * @return self\n   * @public\n   */\n\n\n  disconnect() {\n    if (this.connected) {\n      debug(\"performing disconnect (%s)\", this.nsp);\n      this.packet({\n        type: socket_io_parser_1.PacketType.DISCONNECT\n      });\n    } // remove socket from pool\n\n\n    this.destroy();\n\n    if (this.connected) {\n      // fire events\n      this.onclose(\"io client disconnect\");\n    }\n\n    return this;\n  }\n  /**\n   * Alias for disconnect()\n   *\n   * @return self\n   * @public\n   */\n\n\n  close() {\n    return this.disconnect();\n  }\n  /**\n   * Sets the compress flag.\n   *\n   * @param compress - if `true`, compresses the sending data\n   * @return self\n   * @public\n   */\n\n\n  compress(compress) {\n    this.flags.compress = compress;\n    return this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n   * ready to send messages.\n   *\n   * @returns self\n   * @public\n   */\n\n\n  get volatile() {\n    this.flags.volatile = true;\n    return this;\n  }\n  /**\n   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n   * callback.\n   *\n   * @param listener\n   * @public\n   */\n\n\n  onAny(listener) {\n    this._anyListeners = this._anyListeners || [];\n\n    this._anyListeners.push(listener);\n\n    return this;\n  }\n  /**\n   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n   * callback. The listener is added to the beginning of the listeners array.\n   *\n   * @param listener\n   * @public\n   */\n\n\n  prependAny(listener) {\n    this._anyListeners = this._anyListeners || [];\n\n    this._anyListeners.unshift(listener);\n\n    return this;\n  }\n  /**\n   * Removes the listener that will be fired when any event is emitted.\n   *\n   * @param listener\n   * @public\n   */\n\n\n  offAny(listener) {\n    if (!this._anyListeners) {\n      return this;\n    }\n\n    if (listener) {\n      const listeners = this._anyListeners;\n\n      for (let i = 0; i < listeners.length; i++) {\n        if (listener === listeners[i]) {\n          listeners.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._anyListeners = [];\n    }\n\n    return this;\n  }\n  /**\n   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n   * e.g. to remove listeners.\n   *\n   * @public\n   */\n\n\n  listenersAny() {\n    return this._anyListeners || [];\n  }\n\n}\n\nexports.Socket = Socket;","map":null,"metadata":{},"sourceType":"script"}